{"componentChunkName":"component---src-templates-post-template-js","path":"/2021-06-30/","result":{"data":{"curPost":{"id":"67c2fb0c-f246-529a-b720-8bc29c4b1d3e","html":"<blockquote>\n<p>이 블로그 콘텐츠에는 책 '코어 자바스크립트'를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.</p>\n</blockquote>\n<h1>자바스크립트 프로토타입</h1>\n<p>자바스크립트가 프로토타입 기반의 언어라는 점은 많이 들어서 알고 있을 것이다. 클래스 기반의 언어에 있는 상속과는 다르게 특정한 객체 하나를 원형(prototype)으로 삼고 이를 복제하는 방식으로 상속의 흉내낸다. 프로토타입의 개념을 한 번 이해하는 것이 어렵지만 이번에 해내보자.</p>\n<p><br /><br /></p>\n<h3 id=\"기본\">기본</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 744px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d70b6511e4382951d612185b9fe62a7a/cab8c/prototype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 88.67187499999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAABvUlEQVR42pWU646CQAyFff9X0xgj/DDREEXwiijiDW/dfE06GXAxu5M0M3Q6p6c3Ou/3W1js9/tdqqpSeTwe4t+xXq+XXK9XuVwuKpyR5/Pp7DocAFgul7Lf76UoCjkcDnI+n+V0OkmWZc44z3MVbNixR5IkUQIsBcTLYrGQ4XAovV5PgiCQwWAgYRjqY2N/PB6lLEvp9/vS7XbVdjKZqB5SDpCPzWYj8/lcZrOZpGkqcRzLer1WJhYubJHpdKr3o9FIiWCHQwdIDggZIPbVaqUOEAAtbzwECBuAsCNczrWQ8W65Q8jLbrfTnW/OMDMdgiPTIy5kqyBFID//XZCxpVU2QGNiRui/ibWQb1tjCKAVwHS+56b+drs5dv69AwQM0OZD39jObWAfDGnkNoamoz2sor8xd4A08Xa7/ZpDGpi8+U5aGY7HY22HtmWATfYfDI0RIdOLhI3QQjbb5IwOQE+49ByNjgPuagxtlm30CB2BMYViGpgQpgEHjF0URQoOCUtTDZBE25+FnwLCnOIIFjxiZ+T4MXCPM9g1O8PlEGOYMDGExA47nOAMZnwDjmBPRNh9MGz2nV+9vyy/KD/Mw3I4/CL1sQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"prototype\"\n        title=\"\"\n        src=\"/static/d70b6511e4382951d612185b9fe62a7a/cab8c/prototype.png\"\n        srcset=\"/static/d70b6511e4382951d612185b9fe62a7a/6f3f2/prototype.png 256w,\n/static/d70b6511e4382951d612185b9fe62a7a/01e7c/prototype.png 512w,\n/static/d70b6511e4382951d612185b9fe62a7a/cab8c/prototype.png 744w\"\n        sizes=\"(max-width: 744px) 100vw, 744px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>위의 이미지의 흐름을 정리하면 다음과 같다.</p>\n<ol>\n<li>어떤 생성자 함수를 new 키워드와 함께 호출하면 생성자에서 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성된다.</li>\n<li>인스턴스가 생성될때 <code>__proto__</code>라고 하는 프로퍼티가 자동으로 부여된다.</li>\n<li><code>__proto__</code> 프로퍼티는 Constructor에 있는 prototype 이라고 하는 프로퍼티를 참조한다.</li>\n</ol>\n<p><code>prototype</code>와 <code>__proto__</code>는 모두 객체다. prototype 객체에는 인스턴스가 사용할 메서드를 저장한다. 이를 참조하는 <code>__proto__</code>를 통해 인스턴스가 이 메서드들에 접근할 수 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">const Person = function (name) {\n  this._name = name;\n};\nPerson.prototype.getName = function () {\n  return this._name;\n};\n\nconst dobby = new Person(&#39;Dobby&#39;);\ndobby.__proto__.getName(); //undefined</code>\n        </deckgo-highlight-code>\n<p>위의 예시에서 <code>dobby.__proto__.getName()</code>을 찍어보면 undefined가 나오는 것을 알 수 있다. 함수를 메서드로 호출하면 '.' 앞의 객체가 바로 this가 된다. 그래서 getName 메서드가 묶인 this는 <code>dobby.__proto__</code> 객체가 된다. 이 객체 내부에는 'name'이라는 프로퍼티가 없기 때문에 정의되지 않은 식별자를 찾을때 뱉는 undefined가 나온 것이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">dobby.__proto__.name = &#39;Dobby&#39;;\ndobby.__proto__.getName(); // &#39;Dobby&#39;\n\ndobby.getName(); // &#39;Dobby&#39;</code>\n        </deckgo-highlight-code>\n<p><code>dobby.getName()</code> 처럼 <code>__proto__</code>를 제외하면 this 걱정없이 메서드를 사용할 수 있다. 그 이유는 <code>__proto__</code>가 생략 가능한 프로퍼티이기 때문이다. 자바스크립트의 단순한 문법적인 측면이기 때문에 생략 가능하다는 정도로만 이해하고 넘어가자.</p>\n<p>정리하면, 'new Constructor() 형태로 인스턴스를 생성하면 생략 가능한 프로퍼티 <code>__proto__</code>가 생성되고 이것은 Constructor의 prototype 객체를 참조한다.'</p>\n<p>Array라고 하는 생성자를 직접 콘솔에 찍어보면 prototype과 기본 내장 메서드를 이해할 수 있다.</p>\n<p><br /><br /></p>\n<h3 id=\"prototype-객체-내부의-constructor-프로퍼티\">prototype 객체 내부의 constructor 프로퍼티</h3>\n<p>생성자 함수의 prototype 객체에는 constructor라고 하는 자기 자신을 참조하는 프로퍼티가 있다. 생성된 <code>__proto__</code> 객체에도 존재한다. 이것은 인스턴스와의 관계를 나타내기 위해 필요한 정보인데, 인스턴스의 원형이 무엇인지를 알 수 있는 수단 역할을 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">const array = [1, 2];\nArray.prototype.constructor === Array; // true\narray.__proto__.constructor === Array; // true\narray.constructor === Array; // true\n\nconst array2 = new array.constructor(3, 4);\nconsole.log(array2); // [3, 4]</code>\n        </deckgo-highlight-code>\n<p><br /><br /></p>\n<h3 id=\"프로토타입-체인\">프로토타입 체인</h3>\n<blockquote>\n<p>메서드 오버라이드</p>\n</blockquote>\n<p>prototype 객체를 참조하는 <code>__proto__</code>를 생략할 수 있기 때문에, 인스턴스는 prototype에 정의된 프로퍼티나 메서드를 자신의 것처럼 사용할 수 있는 것처럼 보인다. 아래의 예시를 한 번 보자.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">const Person = function (name) {\n  this.name = name;\n};\nPerson.prototype.getName = function () {\n  return this.name;\n};\n\nconst IU = new Person(&#39;이지은&#39;);\nIU.getName = function () {\n  return &#39;IU는 &#39; + this.name + &#39;이다.&#39;;\n};\nconsole.log(IU.getName()); // &#39;IU는 이지은이다.&#39;\nconsole.log(IU.__proto__.getName.apply(IU)); // &#39;이지은&#39;</code>\n        </deckgo-highlight-code>\n<p>IU 인스턴스에 있는 메서드가 호출된다. Person prototype 객체에 등록된 getName 메서드와 동일한 함 수 명이기 때문에 원본이 있는 그 상태에서 다른 대상을 얹은 것이다.</p>\n<p>오버라이딩 되지 않고, prototype에 등록된 메서드가 동자가헤 하려면, IU 인스턴스에 있는 <code>__proto__</code>에다가 IU 인스턴스를 바라볼 수 있게 등록하면 된다. call, apply 메서드로 바인딩을 해주면 된다. 원본 메서드를 사용하기 위해서 우회를 해야한다는 점이 있다.</p>\n<br />\n<blockquote>\n<p>프로토타입 체인</p>\n</blockquote>\n<p><code>console.dir([1, 2])</code>를 찍어보면 우리에게 익숙한 pop, push와 같은 메서드가 <code>__proto__</code> 프로퍼티 안에 있다는 것을 볼 수 있다. constructor는 <code>f Array()</code>로 배열 생성자 함수를 가르키고 있는 것으로 보인다. 그런데 <strong>proto</strong>안에 또 다른 <strong>proto</strong>가 있는 것을 볼 수 있다.</p>\n<p>그것은 <code>console.dir({a: 1})</code>을 찍어봤을 때의 <strong>proto</strong>와 동일하다는 것을 알 수 있다. 이것은 모든 객체의 <strong>proto</strong>에 Object.prototype이 연결되기 때문이다. 아래의 그림처럼 연결되어 있는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 712px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/11798707c46ecf00221f424de7e50a97/3d4b6/prototype2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.484375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDElEQVR42qWT6QqEMAyE+/4v6E8V8UQR79ssE4hUt26VLYSaUKffxKjIsvZ9pzdLPRGKo5hc16V5nmlZFtq2jTzP4wjDkHff97muntBBJM9zquv6iLIsqSiK4xIEzlsJu65jMZ0YJNM0sZjRshzGrofQgWZd1yMX2/rlEuqu+XoOi2maMlVVVdxPkF9hmFCnwa1t2zIBFiwhH4aBoihi6yCFsJzR3/+yjEOO4/DLTdNQEAScgwi1JEmsI6WkCBrYACVqIMGOS/Tmm/p8IpQERLAkzcYOMRG+Wrsb+JPlvu95ttAj0OIZtSvZzz9Fxx7HkScfHwI2syzjr2qyZhWUeYPAP/+0Ms3StfFvCD88J06AcqYIVwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"prototype\"\n        title=\"\"\n        src=\"/static/11798707c46ecf00221f424de7e50a97/3d4b6/prototype2.png\"\n        srcset=\"/static/11798707c46ecf00221f424de7e50a97/6f3f2/prototype2.png 256w,\n/static/11798707c46ecf00221f424de7e50a97/01e7c/prototype2.png 512w,\n/static/11798707c46ecf00221f424de7e50a97/3d4b6/prototype2.png 712w\"\n        sizes=\"(max-width: 712px) 100vw, 712px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>proto</strong>는 생략이 가능한 프로퍼티이기 때문에 배열은 Object.prototype의 내부 메서드를 자신의 것처럼 사용할 수 있다. <code>array(.__proto__)(.__proto__).hasOwnProperty();</code> 이렇게 말이다.</p>\n<p>이런 것처럼 <code>__proto__</code> 프로퍼티 내부에 <code>__proto__</code> 프로퍼티가 연쇄적으로 이어진 형태를 프로토타입 체인이라고 한다. 이 체인을 따라가며 검색하는 과정을 프로토타입 체이닝이라고 한다.</p>","excerpt":"이 블로그 콘텐츠에는 책 '코어 자바스크립트'를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다. 자바스크립트 프로토타입 자바스크립트가 프로토타입 기반의 언어라는 점은 많이 들어서 알고 있을 것이다. 클래스 기반의 언어에 있는 상속과는 다르게 특정한 객체 하나를 원형(prototype)으로 삼고 이를 복제하는 방식으로 상속의 흉내낸다. 프로토타입의 개념…","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\">자바스크립트 프로토타입</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%EA%B8%B0%EB%B3%B8\">기본</a></li>\n<li><a href=\"#prototype-%EA%B0%9D%EC%B2%B4-%EB%82%B4%EB%B6%80%EC%9D%98-constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\">prototype 객체 내부의 constructor 프로퍼티</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\">프로토타입 체인</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"createdAt":"2021-06-30","title":"JavaScript 프로토타입","categories":"개발 JavaScript","emoji":"👨‍💻","titleImg":null,"tags":"JavaScript"},"fields":{"postSlug":"/2021-06-30/"}},"curPostToc":{"tableOfContents":{"items":[{"url":"#자바스크립트-프로토타입","title":"자바스크립트 프로토타입","items":[{"items":[{"url":"#기본","title":"기본"},{"url":"#prototype-객체-내부의-constructor-프로퍼티","title":"prototype 객체 내부의 constructor 프로퍼티"},{"url":"#프로토타입-체인","title":"프로토타입 체인"}]}]}]}},"nextPost":{"frontmatter":{"title":"JavaScript 실행 컨텍스트","createdAt":"2021-06-19","categories":"개발 JavaScript","emoji":"👨‍💻"},"fields":{"postSlug":"/2021-06-19/"}},"prevPost":{"frontmatter":{"title":"Create-React-App 없이 리액트 프로젝트 보일러 플레이트 세팅하기","createdAt":"2021-08-08","categories":"개발 React","emoji":"👨‍💻"},"fields":{"postSlug":"/2021-08-08/"}},"site":{"siteMetadata":{"title":"hankyeolk-dev-blog","postBasisCategories":["블로그","책","개발","프로덕트","UX","브랜드","인사이트","노션","기타"]}}},"pageContext":{"postSlug":"/2021-06-30/","nextSlug":"/2021-06-19/","prevSlug":"/2021-08-08/"}},"staticQueryHashes":["968848749"],"slicesMap":{}}